#!/usr/bin/env bash
# tk-plugin: Generate Mermaid dependency graph for tickets
# tk-plugin-version: 1.0.0

set -euo pipefail

if [[ -z "${TICKETS_DIR:-}" ]]; then
    echo "Error: TICKETS_DIR not set (are you running this via tk?)" >&2
    exit 1
fi

if [[ ! -d "$TICKETS_DIR" ]]; then
    echo "Error: TICKETS_DIR does not exist: $TICKETS_DIR" >&2
    exit 1
fi

# Resolve partial ticket ID to full ID
resolve_id() {
    local id="$1"
    local exact="$TICKETS_DIR/${id}.md"

    if [[ -f "$exact" ]]; then
        basename "$exact" .md
        return 0
    fi

    local matches count
    matches=$(find "$TICKETS_DIR" -maxdepth 1 -name "*${id}*.md" 2>/dev/null | head -2)
    count=$(printf '%s\n' "$matches" | grep -c . || true)

    if [[ "$count" -eq 1 ]]; then
        basename "$matches" .md
        return 0
    elif [[ "$count" -gt 1 ]]; then
        echo "Error: ambiguous ID '$id' matches multiple tickets" >&2
        return 1
    else
        echo "Error: ticket '$id' not found" >&2
        return 1
    fi
}

roots=()
for arg in "$@"; do
    roots+=("$(resolve_id "$arg")") || exit 1
done

roots_csv=""
if [[ ${#roots[@]} -gt 0 ]]; then
    roots_csv=$(IFS=,; echo "${roots[*]}")
fi

awk -v roots_csv="$roots_csv" '
BEGIN { FS=": "; in_front=0 }
FNR==1 {
    if (prev_file) store()
    id=""; status=""; title=""; deps=""; in_front=0
    prev_file=FILENAME
}
/^---$/ { in_front = !in_front; next }
in_front && /^id:/ { id = $2 }
in_front && /^status:/ { status = $2 }
in_front && /^deps:/ {
    deps = $2
    gsub(/[\[\] ]/, "", deps)
}
!in_front && /^# / && title == "" { title = substr($0, 3) }
function store() {
    if (id != "") {
        statuses[id] = status
        titles[id] = title
        deps_str[id] = deps
    }
}

function safe_id(val,    out) {
    out = val
    gsub(/[^a-zA-Z0-9_]/, "_", out)
    if (out ~ /^[0-9]/) out = "t_" out
    return out
}

END {
    if (prev_file) store()

    root_count = 0
    if (roots_csv != "") {
        n = split(roots_csv, root_arr, ",")
        for (i = 1; i <= n; i++) {
            if (root_arr[i] != "") {
                roots[++root_count] = root_arr[i]
            }
        }
    }

    if (root_count > 0) {
        sp = 0
        for (i = 1; i <= root_count; i++) {
            sp++
            stack[sp] = roots[i]
        }
        while (sp > 0) {
            id = stack[sp]
            sp--
            if (!(id in statuses)) continue
            if (included[id]) continue
            included[id] = 1
            deps = deps_str[id]
            if (deps != "") {
                n = split(deps, arr, ",")
                for (i = 1; i <= n; i++) {
                    dep = arr[i]
                    if (dep != "") {
                        sp++
                        stack[sp] = dep
                    }
                }
            }
        }
    } else {
        for (id in statuses) {
            included[id] = 1
        }
    }

    print "graph TD"
    for (id in included) {
        sid = safe_id(id)
        safe_ids[id] = sid
        label = id " [" statuses[id] "] " titles[id]
        gsub(/"/, "'\''", label)
        print sid "[\"" label "\"]"
    }
    for (id in included) {
        deps = deps_str[id]
        if (deps == "") continue
        n = split(deps, arr, ",")
        for (i = 1; i <= n; i++) {
            dep = arr[i]
            if (dep != "" && (dep in included)) {
                print safe_ids[id] " --> " safe_ids[dep]
            }
        }
    }
}
' "$TICKETS_DIR"/*.md 2>/dev/null
